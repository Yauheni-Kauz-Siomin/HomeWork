package home_work_1;

/*  5 + 2 / 8                                   //корректно работает
	(5 + 2) / 8                                 // корректно работает
	(5 + 2++) / 8                               // ошибка компил€ции,т.к. дл€ пре\постунарного оператора нужно объ€вить и проинициализировать переменную
	(5 + 2++) / --8                             // тоже, что и в предыдущем случае - после инициализации переменной работает корректно
	(5 * 2 >> 2++) / --8                        // тоже, что и в предыдущем случае - после инициализации переменной работает корректно
	(5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8     // тоже, что и в предыдущем случае - после инициализации переменной работает корректно
	(5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8 // ошибка компил€циии из-за неправильной записи тернарного оператора, т.к. после первого услови€ "?" должно идти значение, которое присвоим в случае ответа true, a там сразу же идет второе условие
	6 - 2 > 3 && 12 * 12 <= 119                 //ошибка компил€ции,т.к. нужно т.к. нужно об€ъвить переменную boolean и уже потом сравнить еЄ на выполнение услови€
	true && false                               //ошибка компил€ции,т.к. нужно т.к. нужно об€ъвить переменную boolean и уже потом сравнить еЄ на выполнение услови€
* */



// ѕопытка исправить решение с заданными примерами

public class Task2 {
    public static void main(String[] args) {

        int a = 8;
        int z = 2;


        int b = 5 + z / a;  // 2/8=0, 5+0=5;
        int c = (5 + z) / a; // 5+2=7, 7/8=0;
        int d = (5 + z++) / a; // 5+2=7, 7/8=0, после выполнени€ этой операции z = 3;
        int e = (5 + z++) / --a; // 5+3=8, 8/7=1,после выполнени€ этой операции z = 4; а = 7;
        int f = (5 * z >> z++) / --a;
        int g = (5 + 7 > 20 ? 68 : 22 * z >> z++) / --a;
        int l = (5 + 7 > 20 && 68 >= 68?  68 : 22 * z >> z++) / --a; // второе условие перенес в левую часть
        boolean w = 6 - 2 > 3 && 12 * 12 <= 119; // ответ false, логический оператор », если хот€бы один из операндова false - ответ будет false;  второе сравнение даст ответ false
        boolean v = true && false;  // логический оператор », если хот€бы один из операндова false - ответ будет false;

        System.out.println(b + "-" + c + "-" + d + "-" + e + "-" + f + "-" + g + "-" + l + "-" + w +"-" + w + "-" + v ) ;


    }
}
